// src/index.ts
import fs2 from "fs";
import path2 from "path";
import { cwd as cwd2 } from "process";
import cloneDeep from "lodash.clonedeep";
import merge from "lodash.merge";
import { parse as htmlParser } from "node-html-parser";
import { build as tsupBuild } from "tsup";

// src/constants.ts
var PLUGIN_NAME = "tomjs:vscode";
var PACKAGE_NAME = "@tomjs/vite-plugin-vscode";
var WEBVIEW_PACKAGE_NAME = "@tomjs/vscode-extension-webview";
var WEBVIEW_METHOD_NAME = "__getWebviewHtml__";

// src/logger.ts
import dayjs from "dayjs";
import { blue, gray, green, red, yellow } from "kolorist";
var Logger = class {
  constructor(tag, withTime) {
    this.tag = PLUGIN_NAME;
    this.withTime = true;
    this.tag = `[${tag}]`;
    this.withTime = withTime ?? true;
  }
  getTime() {
    return `${this.withTime ? dayjs().format("HH:mm:ss") : ""} `;
  }
  /**
   * 调试
   */
  debug(msg, ...rest) {
    console.log(`${this.getTime()}${gray(this.tag)}`, msg, ...rest);
  }
  /**
   *  调试日志 等同 debug
   */
  log(msg, ...rest) {
    this.debug(msg, ...rest);
  }
  info(msg, ...rest) {
    console.log(`${this.getTime()}${blue(this.tag)}`, msg, ...rest);
  }
  warn(msg, ...rest) {
    console.log(`${this.getTime()}${yellow(this.tag)}`, msg, ...rest);
  }
  error(msg, ...rest) {
    console.log(`${this.getTime()}${red(this.tag)}`, msg, ...rest);
  }
  success(msg, ...rest) {
    console.log(`${this.getTime()}${green(this.tag)}`, msg, ...rest);
  }
};
var createLogger = (tag) => {
  return new Logger(tag || PLUGIN_NAME, true);
};

// src/utils.ts
import { spawnSync } from "child_process";
import fs from "fs";
import path from "path";
import { cwd } from "process";
function readJson(path3) {
  if (fs.existsSync(path3)) {
    return JSON.parse(fs.readFileSync(path3, "utf8"));
  }
}
function emptyPath(dest) {
  if (fs.existsSync(dest)) {
    fs.rmSync(dest, { recursive: true });
  }
  fs.mkdirSync(dest, { recursive: true });
}
function resolveHostname(hostname) {
  const loopbackHosts = /* @__PURE__ */ new Set([
    "localhost",
    "127.0.0.1",
    "::1",
    "0000:0000:0000:0000:0000:0000:0000:0001"
  ]);
  const wildcardHosts = /* @__PURE__ */ new Set(["0.0.0.0", "::", "0000:0000:0000:0000:0000:0000:0000:0000"]);
  return loopbackHosts.has(hostname) || wildcardHosts.has(hostname) ? "localhost" : hostname;
}
function resolveServerUrl(server) {
  const addressInfo = server.httpServer.address();
  const isAddressInfo = (x) => x == null ? void 0 : x.address;
  if (isAddressInfo(addressInfo)) {
    const { address, port } = addressInfo;
    const hostname = resolveHostname(address);
    const options = server.config.server;
    const protocol = options.https ? "https" : "http";
    const devBase = server.config.base;
    const path3 = typeof options.open === "string" ? options.open : devBase;
    const url = path3.startsWith("http") ? path3 : `${protocol}://${hostname}:${port}${path3}`;
    return url;
  }
}
function getWebviewNpmPath() {
  let npmPath = path.join(cwd(), "node_modules", WEBVIEW_PACKAGE_NAME);
  if (!fs.existsSync(npmPath)) {
    try {
      const res = spawnSync(
        process.platform === "win32" ? "pnpm.cmd" : "pnpm",
        ["list", "--dev", "--depth=1", "--json"],
        {
          // stdio: ['inherit', 'ignore'],
          cwd: process.cwd(),
          encoding: "utf-8"
        }
      );
      if (res.status === 0 && res.stdout) {
        const list = JSON.parse(res.stdout.trim());
        if (list.length === 0) {
          return;
        }
        const self = (list[0].devDependencies || {})[PACKAGE_NAME];
        if (!self) {
          return;
        }
        const dep = self.dependencies[WEBVIEW_PACKAGE_NAME];
        if (dep) {
          npmPath = dep.path;
        }
      }
    } catch {
      npmPath = "";
    }
    if (npmPath) {
      return path.join(npmPath, "dist");
    }
  }
}

// src/index.ts
var isDev = process.env.NODE_ENV === "development";
var logger = createLogger();
function getPkg() {
  const pkgFile = path2.resolve(process.cwd(), "package.json");
  if (!fs2.existsSync(pkgFile)) {
    throw new Error("Main file is not specified, and no package.json found");
  }
  const pkg = readJson(pkgFile);
  if (!pkg.main) {
    throw new Error("Main file is not specified, please check package.json");
  }
  return pkg;
}
function preMergeOptions(options) {
  const pkg = getPkg();
  const opts = merge(
    {
      webview: true,
      recommended: true,
      debug: false,
      extension: {
        entry: "extension/index.ts",
        outDir: "dist-extension",
        target: ["es2019", "node14"],
        format: "cjs",
        shims: true,
        clean: true,
        dts: false,
        treeshake: isDev ? false : "smallest",
        outExtension() {
          return { js: ".js" };
        },
        external: ["vscode"],
        skipNodeModulesBundle: isDev
      }
    },
    cloneDeep(options)
  );
  const opt = opts.extension || {};
  ["entry", "format"].forEach((prop) => {
    const value = opt[prop];
    if (!Array.isArray(value) && value) {
      opt[prop] = [value];
    }
  });
  if (isDev) {
    opt.sourcemap = opt.sourcemap ?? true;
  } else {
    opt.minify ??= true;
  }
  opt.external = ["vscode", WEBVIEW_PACKAGE_NAME].concat(
    opt.external ?? []
  );
  if (!opt.skipNodeModulesBundle) {
    opt.noExternal = Object.keys(pkg.dependencies || {}).concat(
      Object.keys(pkg.peerDependencies || {})
    );
  }
  opts.extension = opt;
  if (opts.webview === true) {
    opts.webview = WEBVIEW_METHOD_NAME;
  }
  opts.webview = opts.webview ?? WEBVIEW_METHOD_NAME;
  return opts;
}
var prodCachePkgName = `${PACKAGE_NAME}-inject`;
function genProdWebviewCode(cache) {
  const prodCacheFolder = path2.join(cwd2(), "node_modules", prodCachePkgName);
  emptyPath(prodCacheFolder);
  const destFile = path2.join(prodCacheFolder, "index.ts");
  function handleHtmlCode(html) {
    const root = htmlParser(html);
    const head = root.querySelector("head");
    if (!head) {
      root == null ? void 0 : root.insertAdjacentHTML("beforeend", "<head></head>");
    }
    head.insertAdjacentHTML(
      "afterbegin",
      `
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{cspSource}} 'unsafe-inline'; script-src 'nonce-{{nonce}}' 'unsafe-eval';">`
    );
    const tags = {
      script: "src",
      link: "href"
    };
    Object.keys(tags).forEach((tag) => {
      const elements = root.querySelectorAll(tag);
      elements.forEach((element) => {
        const attr = element.getAttribute(tags[tag]);
        if (attr) {
          element.setAttribute(tags[tag], `{{baseUri}}${attr}`);
        }
        element.setAttribute("nonce", "{{nonce}}");
      });
    });
    return root.toString();
  }
  const cacheCode = (
    /* js */
    `const htmlCode = {
    ${Object.keys(cache).map((s) => `${s}: \`${handleHtmlCode(cache[s])}\`,`).join("\n")}
  };`
  );
  const code = (
    /* js */
    `import { ExtensionContext, Uri, Webview } from 'vscode';

${cacheCode}

function uuid() {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

export default function getWebviewHtml(webview: Webview, context: ExtensionContext, inputName?:string){
  const nonce = uuid();
  const baseUri = webview.asWebviewUri(Uri.joinPath(context.extensionUri, (process.env.VITE_WEBVIEW_DIST || 'dist')));
  const html = htmlCode[inputName || 'index'] || '';
  return html.replaceAll('{{cspSource}}',webview.cspSource).replaceAll('{{nonce}}', nonce).replaceAll('{{baseUri}}', baseUri);
}
  `
  );
  fs2.writeFileSync(destFile, code, { encoding: "utf8" });
  return destFile.replaceAll("\\", "/");
}
function useVSCodePlugin(options) {
  const opts = preMergeOptions(options);
  const handleConfig = (config) => {
    var _a, _b, _c, _d, _e;
    let outDir = ((_a = config == null ? void 0 : config.build) == null ? void 0 : _a.outDir) || "dist";
    opts.extension ??= {};
    if (opts.recommended) {
      opts.extension.outDir = path2.resolve(outDir, "extension");
      outDir = path2.resolve(outDir, "webview");
    }
    const assetsDir = ((_b = config == null ? void 0 : config.build) == null ? void 0 : _b.assetsDir) || "assets";
    const output = {
      chunkFileNames: `${assetsDir}/[name].js`,
      entryFileNames: `${assetsDir}/[name].js`,
      assetFileNames: `${assetsDir}/[name].[ext]`
    };
    let rollupOutput = ((_d = (_c = config == null ? void 0 : config.build) == null ? void 0 : _c.rollupOptions) == null ? void 0 : _d.output) ?? {};
    if (Array.isArray(rollupOutput)) {
      rollupOutput.map((s) => Object.assign(s, output));
    } else {
      rollupOutput = Object.assign({}, rollupOutput, output);
    }
    return {
      build: {
        outDir,
        sourcemap: isDev ? true : (_e = config == null ? void 0 : config.build) == null ? void 0 : _e.sourcemap,
        rollupOptions: {
          output: rollupOutput
        }
      }
    };
  };
  let webviewClient;
  let webviewNpmPath;
  if (opts.webview) {
    webviewNpmPath = getWebviewNpmPath();
    if (!webviewNpmPath || !fs2.existsSync(webviewNpmPath)) {
      logger.warn(`[${WEBVIEW_PACKAGE_NAME}] is not installed, please install it first!`);
    } else {
      const fileName = "client.global.js";
      const clientFile = path2.join(webviewNpmPath, fileName);
      if (!fs2.existsSync(clientFile)) {
        logger.warn(`[${fileName}] is does not exist, please update the package!`);
      } else {
        webviewClient = fs2.readFileSync(clientFile, "utf-8");
      }
    }
  }
  let buildConfig;
  const prodHtmlCache = {};
  return [
    {
      name: "@tomjs:vscode",
      apply: "serve",
      config(config) {
        return handleConfig(config);
      },
      configureServer(server) {
        var _a;
        if (!server || !server.httpServer) {
          return;
        }
        (_a = server.httpServer) == null ? void 0 : _a.once("listening", async () => {
          const env = {
            NODE_ENV: server.config.mode || "development",
            VITE_DEV_SERVER_URL: resolveServerUrl(server)
          };
          logger.info("extension build start");
          let buildCount = 0;
          const { onSuccess: _onSuccess, ...tsupOptions } = opts.extension || {};
          await tsupBuild(
            merge(tsupOptions, {
              watch: true,
              env,
              silent: true,
              esbuildPlugins: [
                {
                  name: "@tomjs:vscode:inject",
                  setup(build) {
                    build.onLoad({ filter: /\.ts$/ }, async (args) => {
                      const file = fs2.readFileSync(args.path, "utf-8");
                      if (file.includes(`${opts.webview}(`)) {
                        return {
                          contents: `import ${opts.webview} from '@tomjs/vscode-extension-webview';
` + file,
                          loader: "ts"
                        };
                      }
                      return {};
                    });
                  }
                }
              ],
              async onSuccess() {
                if (typeof _onSuccess === "function") {
                  await _onSuccess();
                }
                if (buildCount++ > 1) {
                  logger.info("extension rebuild success");
                } else {
                  logger.info("extension build success");
                }
              }
            })
          );
        });
      },
      transformIndexHtml(html) {
        if (!opts.webview || !webviewClient) {
          return html;
        }
        return html.replace(/<\/title>/i, `</title><script>${webviewClient}</script>`);
      }
    },
    {
      name: "@tomjs:vscode",
      apply: "build",
      enforce: "post",
      config(config) {
        return handleConfig(config);
      },
      configResolved(config) {
        buildConfig = config;
      },
      transformIndexHtml(html, ctx) {
        var _a;
        if (!opts.webview) {
          return html;
        }
        prodHtmlCache[(_a = ctx.chunk) == null ? void 0 : _a.name] = html;
        return html;
      },
      closeBundle() {
        let webviewPath;
        if (opts.webview) {
          webviewPath = genProdWebviewCode(prodHtmlCache);
        }
        let outDir = buildConfig.build.outDir.replace(cwd2(), "").replaceAll("\\", "/");
        if (outDir.startsWith("/")) {
          outDir = outDir.substring(1);
        }
        const env = {
          NODE_ENV: buildConfig.mode || "production",
          VITE_WEBVIEW_DIST: outDir
        };
        logger.info("extension build start");
        const { onSuccess: _onSuccess, ...tsupOptions } = opts.extension || {};
        tsupBuild(
          merge(tsupOptions, {
            env,
            silent: true,
            esbuildPlugins: !opts.webview ? [] : [
              {
                name: "@tomjs:vscode:inject",
                setup(build) {
                  build.onLoad({ filter: /\.ts$/ }, async (args) => {
                    const file = fs2.readFileSync(args.path, "utf-8");
                    if (file.includes(`${opts.webview}(`)) {
                      return {
                        contents: `import ${opts.webview} from \`${webviewPath}\`;
` + file,
                        loader: "ts"
                      };
                    }
                    return {};
                  });
                }
              }
            ],
            async onSuccess() {
              if (typeof _onSuccess === "function") {
                await _onSuccess();
              }
              logger.info("extension build success");
            }
          })
        );
      }
    }
  ];
}
var src_default = useVSCodePlugin;
export {
  src_default as default,
  useVSCodePlugin
};
